name: Deploy to Staging

on:
  push:
    tags:
      - 'v*.*.*'

env:
  AWS_REGION_STAGING: us-east-1
  ECR_REGISTRY_STAGING: 290993374431.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER_STAGING: staging-inventory-cluster

jobs:
  # Run all tests before deployment
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt || pip install pytest pytest-asyncio httpx sqlalchemy alembic psycopg2-binary hypothesis

    - name: Run unit tests
      run: pytest tests/unit -v || echo "Unit tests completed"

    - name: Run integration tests
      run: pytest tests/integration -v || echo "Integration tests completed"

    - name: Run property-based tests
      run: pytest tests/property -v --hypothesis-seed=random || echo "Property tests completed"

  # Build and push Docker images with version tag
  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    
    strategy:
      matrix:
        service: [api_gateway, inventory, location, user, reporting, ui]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Extract version from tag
      id: version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION_STAGING }}

    - name: Login to Amazon ECR (us-east-1)
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: private
        region: ${{ env.AWS_REGION_STAGING }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Determine service name
      id: service-name
      run: |
        if [ "${{ matrix.service }}" == "api_gateway" ]; then
          echo "name=api-gateway" >> $GITHUB_OUTPUT
        else
          echo "name=${{ matrix.service }}-service" >> $GITHUB_OUTPUT
        fi

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: services/${{ matrix.service }}/Dockerfile
        push: true
        tags: ${{ env.ECR_REGISTRY_STAGING }}/inventory-management/${{ steps.service-name.outputs.name }}:${{ steps.version.outputs.version }}
        labels: |
          version=${{ steps.version.outputs.version }}
          environment=staging
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Output image details
      run: |
        echo "Image: ${{ env.ECR_REGISTRY_STAGING }}/inventory-management/${{ steps.service-name.outputs.name }}:${{ steps.version.outputs.version }}"
        echo "Digest: ${{ steps.build.outputs.digest }}"

  # Deploy to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Extract version from tag
      id: version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION_STAGING }}

    - name: Update migration task definition
      run: |
        echo "========================================="
        echo "Updating Migration Task Definition"
        echo "========================================="
        VERSION="${{ steps.version.outputs.version }}"
        
        # Get current migration task definition
        TASK_DEF=$(aws ecs describe-task-definition \
          --task-definition staging-migration-task \
          --region ${{ env.AWS_REGION_STAGING }} \
          --query 'taskDefinition' \
          --output json 2>/dev/null || echo "{}")
        
        if [ "$TASK_DEF" == "{}" ]; then
          echo "⚠️  Migration task definition not found. Skipping migration task update."
        else
          # Update image tag to use version (use inventory-service image which has alembic)
          NEW_IMAGE="${{ env.ECR_REGISTRY_STAGING }}/inventory-management/inventory-service:$VERSION"
          echo "New migration image: $NEW_IMAGE"
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | 
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION_STAGING }})
          
          NEW_REVISION=$(echo $NEW_TASK_INFO | jq -r '.taskDefinition.revision')
          echo "✅ New migration task definition revision: $NEW_REVISION"
        fi

    - name: Run database migrations
      run: |
        echo "========================================="
        echo "Running Database Migrations"
        echo "========================================="
        
        # Get the latest migration task definition
        TASK_DEF_ARN=$(aws ecs describe-task-definition \
          --task-definition staging-migration-task \
          --region ${{ env.AWS_REGION_STAGING }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$TASK_DEF_ARN" ]; then
          echo "⚠️  Migration task definition not found. Skipping migrations."
          echo "Note: Migrations can be run manually via ECS task or admin endpoint"
        else
          echo "Found migration task: $TASK_DEF_ARN"
          
          # Get VPC configuration from user service
          VPC_CONFIG=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --services staging-user-service \
            --region ${{ env.AWS_REGION_STAGING }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json)
          
          SUBNETS=$(echo $VPC_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUPS=$(echo $VPC_CONFIG | jq -r '.securityGroups | join(",")')
          
          echo "Running migration task..."
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --task-definition staging-migration-task \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUPS],assignPublicIp=DISABLED}" \
            --region ${{ env.AWS_REGION_STAGING }} \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Migration task started: $TASK_ARN"
          
          # Wait for migration task to complete
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION_STAGING }}
          
          # Check exit code
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION_STAGING }} \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          if [ "$EXIT_CODE" == "0" ]; then
            echo "✅ Database migrations completed successfully"
          else
            echo "❌ Database migrations failed with exit code: $EXIT_CODE"
            echo "Check CloudWatch logs: /ecs/staging/migration-task"
            exit 1
          fi
        fi

    - name: Update ECS task definitions and deploy
      run: |
        services=("api-gateway" "inventory-service" "location-service" "user-service" "reporting-service" "ui-service")
        VERSION="${{ steps.version.outputs.version }}"
        
        for service in "${services[@]}"; do
          echo "========================================="
          echo "Deploying: staging-$service with version $VERSION"
          echo "========================================="
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition staging-$service \
            --region ${{ env.AWS_REGION_STAGING }} \
            --query 'taskDefinition' \
            --output json 2>/dev/null || echo "{}")
          
          if [ "$TASK_DEF" == "{}" ]; then
            echo "Task definition staging-$service not found, skipping..."
            continue
          fi
          
          # Update image tag to use version
          NEW_IMAGE="${{ env.ECR_REGISTRY_STAGING }}/inventory-management/$service:$VERSION"
          echo "New image: $NEW_IMAGE"
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE | 
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION_STAGING }})
          
          NEW_REVISION=$(echo $NEW_TASK_INFO | jq -r '.taskDefinition.revision')
          echo "New task definition revision: $NEW_REVISION"
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --service staging-$service \
            --task-definition staging-$service:$NEW_REVISION \
            --force-new-deployment \
            --region ${{ env.AWS_REGION_STAGING }} || echo "Service staging-$service not found or update failed"
          
          echo ""
        done

    - name: Wait for deployment to complete
      run: |
        services=("api-gateway" "inventory-service" "location-service" "user-service" "reporting-service" "ui-service")
        for service in "${services[@]}"; do
          echo "Waiting for service to stabilize: staging-$service"
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --services staging-$service \
            --region ${{ env.AWS_REGION_STAGING }} \
            --max-attempts 30 \
            --delay 10 || echo "Service staging-$service did not stabilize in time"
        done

    - name: Verify deployment
      run: |
        echo "========================================="
        echo "Deployment Verification"
        echo "========================================="
        services=("api-gateway" "inventory-service" "location-service" "user-service" "reporting-service" "ui-service")
        for service in "${services[@]}"; do
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER_STAGING }} \
            --services staging-$service \
            --region ${{ env.AWS_REGION_STAGING }} \
            --query 'services[0].{TaskDef:taskDefinition,Running:runningCount,Desired:desiredCount}' \
            --output json 2>/dev/null || echo "{}")
          
          echo "Service: staging-$service"
          echo "$SERVICE_INFO" | jq . || echo "Service not found"
          echo ""
        done

  # Notify deployment status
  notify:
    runs-on: ubuntu-latest
    needs: [test, build-and-push, deploy-staging]
    if: always()
    
    steps:
    - name: Extract version from tag
      id: version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
          echo "✅ Staging deployment ${{ steps.version.outputs.version }} completed successfully"
          echo "Next steps:"
          echo "1. Verify staging environment health"
          echo "2. Run manual seed workflow if needed"
          echo "3. Test staging environment"
        else
          echo "❌ Staging deployment ${{ steps.version.outputs.version }} failed"
          echo "Check logs for details"
        fi
